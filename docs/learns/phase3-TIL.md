# 2026-02-20 Phase 3 금리 등록/조회 API 학습 정리

## 오늘 한 것
- `base_rate`, `spread_rate`, `preferential_rate`, `interest_log` 스키마(V6) 기준으로 금리 도메인 연결
- 금리 등록 API 3종 + 복합금리 조회 API 구현
  - `POST /api/rates/base`
  - `POST /api/rates/spread`
  - `POST /api/rates/preferential`
  - `GET /api/rates/composed`
- Controller 검증/예외 매핑(400/404/409) 정리
- Service/Controller/Repository 테스트 작성 및 회귀 검증
- 로컬 DB 잔존 데이터로 인한 테스트 충돌(BaseRate unique) 안정화

## 배운 것

### 1) 금리 도메인의 기준 키는 `businessDate`
- 금리 등록/조회 모두 `businessDate`를 중심으로 정합성을 맞춰야 함
- 특히 복합금리 조회에서 날짜 기준이 흔들리면, 기준금리/가산금리/우대금리 조합이 서로 다른 시점 데이터가 섞일 수 있음
- 정책을 명확히 분리:
  - 기준금리(`base`) 없음: 실패(예외)
  - 가산/우대 없음: `0.0000`으로 처리 가능

### 2) 정밀도는 구현 상세가 아니라 계약
- 금리는 `DECIMAL(5,4)` + `BigDecimal`로 계산
- 등록 시점과 조회 조합 시점 모두 `setScale(4, RoundingMode.DOWN)`을 동일하게 적용
- 반올림 모드가 다르면 운영 중 재계산 시 결과가 달라질 수 있어, **한 곳에서만 맞추는 게 아니라 전체 흐름에서 통일**이 필요

```kotlin
val appliedRate = baseRate
    .setScale(4, RoundingMode.DOWN)
    .add(spreadRate)
    .add(preferentialRate)
    .setScale(4, RoundingMode.DOWN)
```

### 3) "upsert"라는 이름과 실제 비즈니스 동작을 맞춰야 함
- 구현은 사실상 "중복 등록 불가(create-once)" 정책에 가까움
- 애플리케이션 선조회 + DB unique key를 이중으로 사용해 중복을 차단
- 동시 요청에서는 선조회만으로 방어가 안 되므로, 저장 시 `DataIntegrityViolationException`을 비즈니스 예외(409)로 변환하는 경로가 필요

### 4) 우대조건(conditionCodes) 정규화가 실제 장애를 줄임
- 입력은 공백/중복/빈 값이 섞여 들어올 수 있음
- 조회 전에 `trim -> blank 제거 -> distinct`를 적용해 쿼리 노이즈를 줄이고 결과 일관성 확보
- 조건코드가 비어 있으면 우대금리 조회 쿼리를 생략하는 것이 효율적

### 5) Controller 에러 계약을 먼저 고정해야 클라이언트가 안정됨
- 검증 실패: `400`
- 리소스 미존재(상품/기준금리): `404`
- 중복 등록 충돌: `409`
- `@ExceptionHandler`를 컨트롤러에서 명시해 일관 응답 포맷 유지

### 6) 테스트는 비즈니스 검증 + 운영 환경 노이즈 방어를 함께 봐야 함
- Service 테스트: 성공/중복/미존재/누락금리(0 처리) 케이스
- Controller 테스트: `201/200/400/404/409` 매핑 검증
- Repository 테스트: unique/active 조건 검증
- 로컬 profile + 실제 DB(`Replace.NONE`) 환경에서는 고정 날짜 데이터가 누적될 수 있어, 테스트 데이터 충돌을 피하는 전략이 필요
  - 충돌 가능 테스트는 사용 가능한 날짜를 탐색
  - null 조회 테스트는 대상 날짜 row를 명시적으로 정리 후 검증

### 7) 보안/운영 관점에서 남는 체크포인트
- 금리 등록 API는 운영자 권한 제어가 필수(인가 미적용 상태면 리스크 큼)
- 요청 입력 상한(예: conditionCodes 개수/길이) 제한 필요
- 에러 메시지에 내부 상세를 과도하게 노출하지 않도록 정책화 필요
- 감사로그(누가/언제/무엇을 변경했는지) 설계가 필요

## 면접 포인트 정리
- "금리 조회에서 왜 기준금리 없으면 실패시키나요?"
  - 적용금리의 기준축이 없는 상태는 계산 자체가 의미 없기 때문
- "왜 DB unique만으로 끝내지 않고 서비스에서도 중복 체크하나요?"
  - 사용자 친화적 에러 메시지와 빠른 실패를 위해 선조회가 필요하고,
    동시성 최종 보장은 DB unique가 담당하는 이중 방어 구조가 안전하기 때문
- "왜 BigDecimal + DOWN을 고정했나요?"
  - 금융 계산에서 재현 가능한 결과가 중요하고, 환경별 반올림 차이를 제거하려면 정책 고정이 필요하기 때문

## 수신 백엔드 개발자 관점에서 추가로 고민한 점 (스케줄러/일별 적립)

### 1) businessDate 기준과 타임존 고정
- 배치가 매일 실행돼도 비즈니스 날짜는 서버 로컬 시간이 아니라 명시된 기준 시간대에 맞아야 함
- 실행 cron과 날짜 계산 기준을 `Asia/Seoul`로 고정해 날짜 경계 오차를 줄임

### 2) 배치 운영 연속성 vs 정합성
- 한 계좌 실패로 전체를 중단하면 운영 영향이 큼
- 반대로 전체 continue만 하면 누락 계좌가 생길 수 있음
- 이번 구현은 계좌 단위 실패를 로그로 남기고 다음 계좌를 계속 처리하도록 선택

### 3) 페이지 순회 안정성
- 대량 계좌를 페이지로 처리할 때 정렬 기준이 없으면 누락/중복 위험이 있음
- `id ASC` 정렬을 명시해 페이지 경계가 흔들리지 않도록 함

### 4) 재처리/중복 실행 안전성
- 스케줄러는 재실행될 수 있으므로 멱등 방어가 필수
- 서비스 레벨에서 선조회 + 분산락 + DB unique 충돌 복구 경로를 유지해 중복 적립 방지

### 5) 금리 미설정 계좌 처리 정책
- 기준금리/가산금리 미설정은 조용히 0 처리하지 않고 실패로 드러내 운영 이슈를 인지하게 함
- 데이터 품질 문제를 조기에 발견하기 위한 선택

### 6) 계좌 라이프사이클 검증
- 해지 계좌, 개설일 이전, 해지일 이후 날짜는 적립 금지
- 배치에서도 도메인 검증을 동일하게 적용해 규칙 일관성 유지

### 7) 정밀도 정책 고정
- `BigDecimal`만 사용, 적용금리 scale(4), 이자금액 scale(2), 절사(`DOWN`) 정책을 고정
- 재계산 시점이 달라도 같은 입력이면 같은 결과가 나오도록 보장

### 8) 우대조건 기본값 전략
- 스케줄러 기본 요청은 `conditionCodes=[]`로 처리
- 우대 조건 충족 판단은 외부 이벤트/실적 데이터 정합성과 함께 별도 확장할 수 있게 분리

## 다음 할 것
- 금리 등록 API 인가(권한) 적용
- conditionCodes 입력 상한/패턴 검증 강화
- 예외 메시지 표준화(내부 정보 노출 최소화)
- 감사로그 및 변경 이력 조회 정책 정리
